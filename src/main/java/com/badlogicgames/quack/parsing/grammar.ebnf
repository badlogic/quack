CompilationUnit ::= ModuleDeclaration 
                    (ImportDeclaration)* 
                    (StructDefinition | FunctionDefinition)*

ModuleDeclaration ::= "module" ModuleName

ImportDeclaration ::= "import" ModuleName

ModuleName ::= IDENTIFIER ( "." IDENTIFIER )*

StructDefinition ::= "struct" IDENTIFIER (GenericParameters)? "{"
                        (FieldDeclaration)*
                        (FunctionDefinition)*
                     "}"
      
GenericParameters ::= "<" GenericParameter ("," GenericParameter)* ">"

GenericParameter ::= IDENTIFIER | BuildInType

FieldDeclaration ::= ("static")? ("val" | "var") IDENTIFIER (":" Type)? ("=" Expression)?

FunctionDefinition ::= "def" (IDENTIFIER | ArrayOp) (GenericParameters)? ArgumentList (":" Type)? "{"
                          FunctionBody
                       "}"

ArrayOp ::= ("[]get" | "[]set")

ArgumentList ::= "(" (Argument ("," Argument)*)? ")"

Argument ::= IDENTIFIER ":" Type ("=" Expression)?

FunctionBody ::= StatementList

StatementList ::= (Statement)*

Statement ::= VariableDeclaration |
              AssignmentOrExpression |
              Block |
              IfBlock |
              WhileBlock |
              ForBlock |
              Return

VariableDeclaration ::= FieldDeclaration

Block ::= "{" StatementList "}"

IfBlock ::= "if" "(" Expression ")" Block
            (ElseIfBlock)*
            ("else" Block)?
ElseIfBlock ::= "elif" "(" Expression ")" Block

WhileBlock ::= "while" "(" Expression ")" Block

ForBlock ::= "for" "(" ForInitializer ";" Expression ";" ForBottm ")" Block

ForInitializer ::= (VariableDeclaratin ("," VariableDeclaration)*)?

ForBottom ::= (AssignmentOrExpression ("," AssignmentOrExpression)*)?

Return ::= "return" (Expression)*

AssignmentOrExpression ::= Expression ("=" Expression)?

Expression ::= LogicalExpression

LogicalExpression ::= BitExpression (("||" | "&&") BitExpression)*

BitExpression ::= EqualityExpression (("&" | "|" | "^") EqualityExpression)*

EqualityExpression ::= RelationalExpression (("==" | "!=") RelationalExpression)*

RelationalExpression ::= ShiftExpression (("<" | ">" | "<=" | ">=") ShiftExpression)*

ShiftExpression ::= AddExpression (("<<" | ">>") AddExpression)*

AddExpression ::= MultExpression (("+" | "-") MultExpression)*

MultExpression ::= UnaryExpression (("*" | "/" | "%") UnaryExpression)*

UnaryExpression ::= PostfixExpression | 
                    ("!" | "+" | "-") UnaryExpression
                    "typeof" "(" (Expression | BuildInType) ")" |
                    "sizeof" "(" (Expression | BuildInType) ")" |
                    "cast" "<" Type ">" "(" Expression ")"

PostfixExpression ::= PrimaryExpression
                      (
                         "[" Expression "]" | 
                         (GenericTypeList)? "(" (ArgumentExpressionList)? ")" |
                         "." IDENTIFIER
                      )?

ArgumentExpressionList ::= ArgumentExpression ("," ArgumentExpression)*

ArgumentExpression ::= (IDENTIFIER ":")? Expression

GenericTypeList ::= "<" Type ("," Type)* ">"

PrimaryExpression ::= IDENTIFIER | Constant | "(" Expression ")"

Constant ::= "null" | ("true" | "false") | FLOATING_POINT_LITERAL | CHARACTER_LITERAL | STRING_LITERAL

BuildInType ::= "bool" | 
                "uint8" | "uint16" | "uint32" | "uint64" |
                "int8" | "int16" | "int32" | "int64" |
                "float32" | "float64"

Type ::= BuildInType |
         IDENTIFIER (GenericTypeList)? |
         (GenericTypeList)? ArgumentList (":" Type)

IDENTIFIER ::= LETTER (PART_LETTER)*
LETTER ::= ('A'-'Z'|'_'|'a'-'z')
PART_LETTER ::= ('0'-'9'|'A'-'Z'|'_'|'a'-'z')